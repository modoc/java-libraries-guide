{"./":{"url":"./","title":"扔掉自己造的轮子","keywords":"","body":"Java库使用指南 集合工具 主要来自Apache Commons、Guava。 "},"collection/":{"url":"collection/","title":"集合","keywords":"","body":"集合工具 包含所有集合（包括Map）之间的转换、操作工具。 "},"collection/iterable2iterable.html":{"url":"collection/iterable2iterable.html","title":"Iterable到Iterable","keywords":"","body":"Iterable到Iterable List[F]转化为List[T] List[E]过滤为List[E] Set[F]转化为Set[T] Set[E]过滤为Set[E] List[F]转化为List[T] 在Apache Commons包里面似乎不支持这种不同类型间转化的语义，而Guava中进行这种操作的语义叫做transform： // import com.google.common.collect.Lists List list = Lists.newArrayList(\"abc\", \"edf\", \"afr\"); List characters = Lists.transform(list, s -> s.charAt(0)); // characters = [a, e, a] List[E]过滤为List[E] 诡异的是，无论commons-collections4还是guava，都没有提供List的filter方法，当然也可以通过guava的Collections2间接实现： // import com.google.common.collect.Collections2 List list = Lists.newArrayList(\"abc\", \"edf\", \"afr\"); List characters = new ArrayList<>(Collections2.filter(list, s -> s.startsWith(\"a\"))); // characters = [abc, afr] Set[F]转化为Set[T] 或许因为Set转化之后目标集合和原集合不一定一一对应，Guava没有为Set提供transform方法，但是可以通过Collections2间接实现： // import com.google.common.collect.Collections2 Set set = Sets.newHashSet(\"abc\", \"edf\", \"afr\"); Set characters = new HashSet<>(Collections2.transform(set, s -> s.charAt(0))); // characters = [a, e] Set[E]过滤为Set[E] // import com.google.common.collect.Sets Set set = Sets.newHashSet(\"abc\", \"edf\", \"afr\"); Set characters = Sets.filter(set, s -> s.startsWith(\"a\")); // characters = [abc, afr] "},"collection/iterable2array.html":{"url":"collection/iterable2array.html","title":"Iterable到Array","keywords":"","body":"Iterable到Array Collection[Boolean] to Array[Boolean] Collection[Boolean] to Array[Boolean] Boolean的转化可以有更简单的方式： // import com.google.common.primitives.Booleans boolean[] result = Booleans.toArray(collection); "},"collection/mapnew.html":{"url":"collection/mapnew.html","title":"创建Map","keywords":"","body":"Map的创建 用KV对创建 用KV对创建 Map的创建本身很简单，new一个实例化对象就可以，但是如果想在创建的时候填充KV对，就会比较麻烦，尤其是在定义静态全局变量的时候，如果不用工具，需要（Java8及以下）： // Java9以后请直接用Map.of(...) private static Map map = new HashMap<>(); static { map.put(k1, v1); } 如果初始化的KV对在5对以下，使用guava中的： // import com.google.common.collect.ImmutableMap private static Map map = ImmutableMap.of(k1, k1); 如果kv对在6对以上，使用： // import com.google.common.collect.ImmutableMap private static Map map = ImmutableMap.builder() .put(k1, v1) .put(k2, v2) // ... .put(kn, vn) .build(); 但是注意，这样创建的Map是不能修改的Map，如果想要修改，需要在完成套上new XxxMap<>(...)。 如果项目已经升级到Java9，这个事情就更简单，10对KV以下都可以直接使用： private static Map map = Map.of(k1, k1); "},"primitive/":{"url":"primitive/","title":"基础数据类型及包装类","keywords":"","body":"基础数据类型 个人比较希望有但目前没有找到的方法： String to 基础类型 例如： Boolean.valueOf(String.valueOf(o)); Integer.valueOf(String.valueOf(o)); 如果可以使用下面的语句完成就更完美了： BooleanUtils.valueOf(obj); IntegerUtils.valueOf(obj); "},"primitive/boolean.html":{"url":"primitive/boolean.html","title":"Boolean","keywords":"","body":"Boolean 持有引用 OrAndXor toString 持有引用 当把基础数据类型作为参数调用某方法，修改并不会修改原引用的值，如果希望修改原引用，则需要封装成对象之后传递给方法。 // import org.apache.commons.lang3.mutable MutableBoolean sth = new MutableBoolean(true); sth.setValue(false); sth.setTrue(); OrAndXor MutableBoolean封装有点美中不足的是，没有提供or/and等方法，这些小工具在某些场景下还是很实用的，目前可以使用下面的工具方法替代，但还是不如集成到MutableBoolean简洁，某些语言中就直接集成到了bool型里： // import org.apache.commons.lang3.BooleanUtils BooleanUtils.or(b1, b2); BooleanUtils.xor(b1, b2); BooleanUtils.and(b1, b2); toString 如果希望布尔型变量能够输出成true/false之外的字符串，可以： // import org.apache.commons.lang3.BooleanUtils BooleanUtils.toStringTrueFalse(b); // = true / false BooleanUtils.toStringOnOff(b); // = on / off BooleanUtils.toStringYesNo(b); // = yes / no BooleanUtils.toString(b, \"right\", \"wrong\"); // = right / wrong "}}